\section{Ejercicio 2}

\subsection{Introducción}
	El segundo problema consistió en la implementación de un algoritmo capaz de dar solución al problema que se plantea a continuación:

	 Decidir si un grupo de n personas pueden formar o no una ronda que cumpla con las siguientes restricciones:
	\begin{itemize}
	      \item La ronda debe contener a todas las personas.
	      \item Algunas personas son amigas y otras no. 
	      \item Cada alumna debe tomar de la mano a dos de sus amigas.
	 
	\end{itemize}

	
\subsection{Explicación}
	Dado que para este problema no se conocen algoritmos buenos\footnote{Un algoritmo se considera bueno si puede ser resuelto en tiempo polinomial.},
	se pensó en utilizar la solución por fuerza bruta, es decir, intentar todas las combinaciones hasta lograr determinar si hay o no solución, pero, agregando 
	algunas mejoras.

	Mejoras como evaluar, en el momento de cargar la ronda, si alguna persona no tiene las suficientes amigos, es decir 2, o si todos son amigos de todos.	

	Luego, se pensó en la estrategia de ``Vuelta atrás'', (Backtracking).
\\ \\ \\
\textit{
\underline{\textbf{Backtracking:}}\\
En su forma básica, la idea de backtracking se asemeja a un recorrido en profundidad dentro de un grafo dirigido. El grafo en cuestión suele ser un árbol, o por lo menos no contiene ciclos. Sea cual sea su estructura, existe sólo implícitamente. El objetivo del recorrido es encontrar soluciones para algún problema. Esto se consigue construyendo soluciones parciales a medida que progresa el recorrido; estas soluciones parciales limitan las regiones en las que se puede encontrar una solución completa. El recorrido tiene éxito si, procediendo de esta forma, se puede definir por completo una solución. En este caso el algoritmo puede bien detenerse (si lo único que se necesita es una solución del problema) o bien seguir buscando soluciones alternativas (si deseamos examinarlas todas). Por otra parte, el recorrido no tiene éxito si en alguna etapa la solución parcial construida hasta el momento no se puede completar. En tal caso, el recorrido vuelve atrás exactamente igual que en un recorrido en profundidad, eliminando sobre la marcha los elementos que se hubieran añadido en cada fase. Cuando vuelve a un nodo que tiene uno o más vecinos sin explorar, prosigue el recorrido de una solución.
}\footnote{http:\/\/es.wikipedia.org\/}
\\ \\

En este caso particular, la idea es, seleccionar una persona (P), ingresarla en la ronda, e ir armando un arbol implicito de posibilidades en donde
el nodo padre es P y cada rama se forma con las distintas selecciones de amigas de P y sus sub-arboles, con las combinaciones posibles de amigas del nodo padre en el que esté.
Para ello se utiliza la recursión, en donde se intenta bajar lo más posible en el arbol hasta llegar a formar un camino desde el primer nodo hasta alguna hoja en donde se encuentren
todas las chicas con nodos padre e hijo amigas.

También, se implementaron otras mejoras que intentan podar el arbol dadas ciertas condiciones que permitan acortar las posibilidades:
\begin{itemize}
 \item Las amigas de un nodo se pueden procesar en cualquier orden, pero decidimos intentar ser lo más restrictivo posible con las primeras (las que tienen menos amigas primero). Este proceso poda el árbol de búsqueda antes de que se tome la decisión y se llame a la subrutina recursiva.
 \item Cuando se elige qué valor se va a asignar, se hace un examen comprobando que aun queden amigas de la que inicio la ronda dispoibles. En caso que no, se pueden evitar muchas llamadas sin sentido.
\end{itemize}

A continuación se ve un pseudocodigo que muestra el comportamiento de la estrategia y las mejoras elegidas.

\vspace{3cm}
\underline{Algunos detalles:}

\begin{itemize}
 \item \textbf{gente} es una lista con elementos de tipo chica.
 \item el tipo \textbf{chica} consta de un nombre (int) y sus amigas (conjunto de nombres).
 \item \textbf{enRonda} es un conjunto de nombres donde se va almacenando quienes pertenecen a la ronda.
 \item \textbf{amigasPrimera} es un conjunto de nombres donde se almacenan los nombres de las amigas de la chica que comienza la ronda.
 \item \textbf{tam(c)} devuelve el tamaño del conjunto c.
 \item \textbf{insertar(c,e)} inserta a e en el conjunto c.
 \item \textbf{borrar(c,e)} borra a e del conjunto c.
 \item \textbf{cuenta(c,e)} cuenta la cantidad de apariciones del elemento e en c.
 \item \textbf{primerElemento(l)} devuelve el primer elemento de una lista.
\end{itemize}

\newpage

\incmargin{1em}
\linesnumbered
\restylealgo{boxed}

\textbf{resolver()}\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{T(n)}
		\BlankLine
		\textbf{var} n : int $\leftarrow$ tam(gente) \\
		\textbf{var} sonPocas : bool $\leftarrow$ false \\
		\textbf{var} sonSuficientes : bool $\leftarrow$ false \\
		
	  \ForEach{k en gente}{
		  sonPocas $\leftarrow$ sonPocas or tam(amigas(k)) $<$ 2;\\
		  sonSuficientes $=$ sonSuficientes $\&\&$ tam(amigas(k)) $==$ n-1);
	   }
    \If{(sonSuficientes)}{retornar true}
    \If{(sonPocas)}{retornar false}

	\textbf{var} solitaria : chica $\leftarrow$ primerElemento(gente);

	insertar(nombre(solitaria),enRonda);

	retornar  probarDistintasRondas(solitaria,solitaria);
	\BlankLine




	  \end{algorithm}
	  


%segundo algoritmo:
\incmargin{1em}
\linesnumbered
\restylealgo{boxed}

\textbf{probarDistintasRondas(prim : chica, ult : chica)}\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{T(n)}
		\BlankLine
	\eIf{(cuenta(amigas(ult),nombre(prim)) $\neq$ 0 $\&\&$ tam(gente) $=$ tam(enRonda) )}{retornar true;}{
		\textbf{var} res : bool\\
		\textbf{var} eraAmiga : bool $\leftarrow$ false \\
\BlankLine		
\ForEach{chi en gente}{
		\textbf{var} estaEnRonda : int $\leftarrow$ cuenta(enRonda,nombre(chi)) \\
		\textbf{var} esAmigaDeLaUltima : int $\leftarrow$ cuenta(amigas(ult),nombre(chi)) \\
		\textbf{var} restantesAmigasPrimera : int $\leftarrow$ tam(amigasPrimera) \\
		\textbf{var} esAmigaDeLaPrimera : int $\leftarrow$ cuenta(amigas(prim),nombre(chi)) \\
		  \BlankLine
	\If {( (estaEnRonda $=$ 0) $\&\&$ (esAmigaDeLaUltima $\neq$ 0) $\&\&$ (restantesAmigasPrimera $\neq$ 0) )}{
\BlankLine	
			\eIf{(esAmigaDeLaPrimera $\neq$ 0)}{
					eraAmiga $\leftarrow$ true;\\
					eliminar(amigasPrimera,nobre(chi));
				}{
					eraAmiga = false;
				}
				insertar(enRonda,nombre(chi));\\
				res $\leftarrow$ probarDistintasRondas(prim,chi);
\BlankLine	
			\eIf{(res)}
				{
					retornar true;
				}
				{
					borrar(enRonda,nombre(chi));\\
\BlankLine	
				\If{(eraAmiga)}{insertar(amigasPrimera,nombre(chi))}
						}
				}	
		}
		retornar false;
	}	


  \end{algorithm}



\subsection{Análisis de la complejidad del algoritmo}

La complejidad en el peor caso de este algoritmo surge inmediatamente al hacer pruebas. Dependiendo de las entradas elegidas, el programa podria tener que 
recorrer casi todas las ramas del arbol hasta poder decir que no hay solucion. En este caso, podriamos entonces solo acotar el peor caso por la funcion $f(n) = c.(n-1)! + b$ 
(donde b y c son constantes) ya que la cantidad de formas de armar una ronda con n personas es (n!/n) = (n-1)!\footnote{Se lo puede imaginar como una fila de n personas. Para la primer posición hay n personas dispoibles, para la segunda n-1, y asi sucesivamente. Por lo tanto hay n*(n-1)*...*1 formas de acomodar las personas en una fila. Ahora, si se unen las puntas, podria rotar la fila n veces y seguiria siendo la misma ronda, por lo tanto se dividiendo por n obtengo la respuesta: \textbf{(n-1)!}.} 

Por lo tanto, el algoritmo implementado NO es bueno. Sin embargo, cuando para un conjunto de datos de entrada se puede formar una ronda, el algoritmo no recorre todo el arbol en busca de la solución, sino que al encontrar una termina. Esta propiedad del backtracking y el resto de las mejoras, hace que para ciertos datos de entradas en donde se pueden formar rondas, el algoritmo se comporte como lo haria una solucion polinomial.


%\subsection[Detalles de Implementación}
%\subsection{Resultados}
%\subsection{Debate}
%\subsection{Comentarios}
%\subsection{Conclusiones}
