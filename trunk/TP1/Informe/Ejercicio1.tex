\section{Ejercicio 1}

\subsection{Introducción}
	El primer problema del presente trabajo consistió en la implementación de un algoritmo capaz de dar solución a la ecuación 
	\begin{equation} 
		b^n\ mod\ (n)
	\label{problema}
	\end{equation}
haciendo uso de alguna de las técnicas algorítmicas aprendidas hasta el momento en la materia. Asímismo, la consigna dictaba que la complejidad final del algoritmo debería ser menor a \Ode{n}.\\
	En pos de cumplimentar lo pedido se decidió usar la técnica de \textit{Dividir \& Conquistar}\footnote{Poner alguna referencia 	en donde se explique esta técnica} para desarrollar el algoritmo. Esta técnica se caracteriza principalmente en dividir la instancia de un problema en instancias más pequeñas, atacar cada una de ellas por separado y resolverlas, para finalmente juntar sus resultados y así producir el resultado final.

\subsection{Explicación}
	La primera solución que se piensa casi de manera intuitiva es la de mutliplicar \textit{n} veces el número \textit{b} y luego hallar el resto de dividir ese resultado por \textit{n}. 
	\begin{equation}
		\underbrace{b.b.b \hdots b.b.b}_{n\ veces}\ mod\ (n)  = b^n\ mod\ (n)
	\label{primera_idea}		
	\end{equation}
Sin embargo, la complejidad ese algoritmo es \Ode{n}, ya que se realizan \textit{n} multipicaciones y 1 división, razón por lo cual no cumple con lo pedido en la consigna. Además, puesto que ese algoritmo realizar sucesivas multipliciones de \textit{b}, cabe la posibilidad de que el valor en que se va acumulando el resultado sobrepase el máximo número entero representable en la computadora produciedo así un overflow y obteniéndose en consecuencia un resultado incorrecto. \\

	Analizando la falla del algoritmo anterior, se observa que lo que se debe evitar es calcular directamente el resultado de $b^n$ ya que ese número podría ser excesivamente grande. \\
Con esto en mente veamos una manera más conveniente de abordar el problema. Es claro, por definición de congruencia, que resover la ecuación en (\ref{problema}) equivale a hallar el $x$ tal que:
	\begin{equation}
		b^n\ \equiv\ x\ (n)\ , \hspace{10pt}\ con\ 0\ \leq\ x\ <\ n 
	\label{problema2}
	\end{equation}

Luego, asumamos por un momento que podemos tener gratis un k tal que:
	\begin{equation}
		b^{n/2}\ \equiv\ k\ (n)\ , \hspace{10pt}\ con\ 0\ \leq\ k\ <\ n 
	\label{divide}
	\end{equation}

Entonces, aplicando el resultado de (\ref{divide}) en (\ref{problema2}) obtenemos que:
	\begin{itemize}
		\item{
		Si \textit{n} es par:
			\begin{eqnarray}
				b^n\ \equiv\ x\ (n)\ , \hspace{10pt}\ con\ 0\ \leq\ x\ <\ n \nonumber\\
				b^{n/2}.b^{n/2}\ \equiv\ x\ (n) \nonumber\\
				k.k\ \equiv\ x\ (n) \nonumber\\
				k^2\ \equiv\ x\ (n)
			\end{eqnarray}
		}
		
		\item{
		Si \textit{n} es impar par:
			\begin{eqnarray}
				b^n\ \equiv\ x\ (n)\ , \hspace{10pt}\ con\ 0\ \leq\ x\ <\ n \nonumber\\
				b.b^{n/2}.b^{n/2}\ \equiv\ x\ (n) \nonumber\\
				b.k.k\ \equiv\ x\ (n) \nonumber\\
				b.k^2\ \equiv\ x\ (n) 
			\end{eqnarray}
		}
	\end{itemize}
Sin lugar a dudas, las expresiones resultantes en ambos casos son fáciles de resolver ya que $k < n$;  al tiempo que también son números mucho menores que $b^n$. \\

Volviendo un poco sobre nuestro pasos, se dijo anteriormente en (\ref{divide}) que podíamos asumir que obtener $k$ no tenía un costo computacional significativo. No obstante, esto no siempre es cierto puesto que para obtener $k$ es necesario calcular previamente $b^{n/2}$ el cual puede ser un número nada despreciable en lo que respecta a tamaño en memoria.\\
Pero esto no representa, dificultad alguna para calcular $b^{n/2}$ puesto que podemos aplicar repetidas veces el procedimiento descripto con anterioridad dividiendo el exponente de $b$ hasta que valga 1, y luego reagrupando los resultados y tomando módulo $n$ hasta obtener finalmente la solución del problema.
 
%\subsection{Análisis de la complejidad del algoritmo}
%\subsection[Detalles de Implementación}
%\subsection{Resultados}
%\subsection{Debate}
%\subsection{Comentarios}
%\subsection{Conclusiones}
