\section*{Ejercicio 1}

\subsection*{Introducción}
	El primer problema del presente trabajo consistió en la implementación de un algoritmo capaz de dar solución a la ecuación 
	\begin{equation} 
		b^n\ mod\ (n) 
	\end{equation} 
haciendo uso de alguna de las técnicas algorítmicas aprendidas hasta el momento en la materia. Asímismo, la consigna dictaba que la complejidad final del algoritmo debería ser menor a \Ode{n}.\\
	En pos de cumplimentar lo pedido se decidió usar la técnica de \textit{Dividir \& Conquistar}\footnote{Poner alguna referencia 	en donde se explique esta técnica} para desarrollar el algoritmo. Esta técnica se caracteriza principalmente en dividir la instancia de un problema en instancias más pequeñas, atacar cada una de ellas por separado y resolverlas, para finalmente juntar sus resultados y así producir el resultado final.

\subsection*{Detalles de implementación}
	La primera solución que se piensa casi de manera intuitiva es la de mutliplicar \textit{n} veces el número \textit{b} y luego hallar el resto de dividir ese resultado por \textit{n}. 
	\begin{equation}
		\underbrace{b.b.b \hdots b.b.b}_{n\ veces}\ mod\ (n)  = b^n\ mod\ (n)
	\end{equation}
Sin embargo, la complejidad ese algoritmo es \Ode{n}, ya que se realizan \textit{n} multipicaciones y 1 división, razón por lo cual no cumple con lo pedido en la consigna.\\
No obstante, la idea anterior conduce a otra forma de encarar el problema. Veamos de qué se trata. \\

	Sabemos que $b^n\ mod\ (n)$ es el resto de dividir $b^n$ por $n$. Llamemos \textit{x} a ese resto. Luego: 
	\begin{equation}
		 x = b^n\ mod\ (n)\ , \hspace{10pt}con\ 0 \leq x < n
	\end{equation}
ya que el Algoritmo de División de Números Enteros asegura que el resto existe, es único y es un valor entre 0 y \textit{n}.\\

	Inmediatamente de lo anterior, por la definición de congruencia, se desprende que:
	\begin{equation}
		b^n\ \equiv\ x\ (n)
	\label{primera_idea}
	\end{equation}

	Luego, una de las propiedades de congruencias, nos asegura que:
	\begin{equation}
		a \equiv p (n)\ ,\ b \equiv q (n)\ \Longrightarrow\ a.b \equiv p.q (n)\ , \hspace{10pt} \forall\ a,b,p,q,n \in \mathbf Z
	\end{equation}
por lo que, tomando en particular, $a=b$ sigue que:
	\begin{equation}
		b \equiv\ p (n)\ \Longrightarrow\ b.b \equiv p.p\  \Leftrightarrow\ b^2 = p^2 (n)
	\label{resto_b2}
	\end{equation}

	Sea ahora \textit{k} el resto de la division de $ p^2 $ por \textit{n}; luego:
	\begin{equation}
		p^n\ \equiv\ k\ (n)\ , \hspace{10pt} con\ 0 \leq k < n
	\label{resto_p2}
	\end{equation}

	Por lo tanto, de \ref{resto_b2} y \ref{resto_p2} se obtiene usando la propiedad transitiva de congruencias que:
	\begin{equation}
		b^2 \equiv p^2 (n)\ ,\ p^2 \equiv k (n)\ \Longrightarrow\ b^2 \equiv k (n)
	\label{segunda_idea}
	\end{equation}
donde por \ref{resto_p2} sabíamos que $k$ es un número entre 0 y $n$.\\

	De este modo, podemos aplicar el resultado de \ref{segunda_idea} en \ref{primera_idea}, obteniéndose:
	\begin{equation}
		b^n = \underbrace{b.b.b \hdots b.b.b}_{n\ veces}\ \equiv\ x (n) \\
		b^n = \underbrace{b^2. b^2 \hdots b^2. b^2}_{n/2\ veces}\ \equiv\ x (n) \\
		b^n = \underbrace{k. k \hdots k. k}_{n/2\ veces}\ \equiv\ x (n)
	\label{idea_final}
	\end{equation}
	

%\subsection*{Análisis de la complejidad del algoritmo}
%\subsection*{Debate}
%\subsection*{Comentarios}
%\subsection*{Conclusiones}
