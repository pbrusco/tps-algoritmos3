\section{Ejercicio 2}

\subsection{Introducción}
	El segundo problema consistió en la implementación de un algoritmo capaz de dar solución al problema que se plantea a continuación:

	 Decidir si un grupo de n personas pueden formar o no una ronda que cumpla con las siguientes restricciones:
	\begin{itemize}
	      \item La ronda debe contener a todas las personas.
	      \item Algunas personas son amigas y otras no. 
	      \item Cada alumna debe tomar de la mano a dos de sus amigas.
	 
	\end{itemize}

	
\subsection{Explicación}
	Dado que para este problema no se conocen algoritmos buenos\footnote{Un algoritmo se considera bueno si puede ser resuelto en tiempo polinomial.},
	se pensó en utilizar la solución por fuerza bruta, es decir, intentar todas las combinaciones hasta lograr determinar si hay o no solución, pero, agregando 
	algunas mejoras.

	Mejoras como evaluar, en el momento de cargar la ronda, si alguna persona no tiene las suficientes amigos, es decir 2, o si todos son amigos de todos.	

	También a este método, se le agregó la estrategia de ``Vuelta atrás'', (Backtracking).
\\ \\ \\
\textit{
\underline{\textbf{Backtracking:}}\\
En su forma básica, la idea de backtracking se asemeja a un recorrido en profundidad dentro de un grafo dirigido. El grafo en cuestión suele ser un árbol, o por lo menos no contiene ciclos. Sea cual sea su estructura, existe sólo implícitamente. El objetivo del recorrido es encontrar soluciones para algún problema. Esto se consigue construyendo soluciones parciales a medida que progresa el recorrido; estas soluciones parciales limitan las regiones en las que se puede encontrar una solución completa. El recorrido tiene éxito si, procediendo de esta forma, se puede definir por completo una solución. En este caso el algoritmo puede bien detenerse (si lo único que se necesita es una solución del problema) o bien seguir buscando soluciones alternativas (si deseamos examinarlas todas). Por otra parte, el recorrido no tiene éxito si en alguna etapa la solución parcial construida hasta el momento no se puede completar. En tal caso, el recorrido vuelve atrás exactamente igual que en un recorrido en profundidad, eliminando sobre la marcha los elementos que se hubieran añadido en cada fase. Cuando vuelve a un nodo que tiene uno o más vecinos sin explorar, prosigue el recorrido de una solución.
}\footnote{http:\/\/es.wikipedia.org\/}
\\ \\

En este caso particular, la idea es, seleccionar una persona (P), ingresarla en la ronda, 

\vspace{3cm}
\incmargin{1em}
\linesnumbered
\restylealgo{boxed}

\textbf{resolver()}\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{T(n)}
		\BlankLine
		\textbf{var} n : int $\leftarrow$ tam(gente) \\
		\textbf{var} sonPocas : bool $\leftarrow$ false \\
		\textbf{var} sonSuficientes : bool $\leftarrow$ false \\
		
	  \ForEach{k en gente}{
		  sonPocas $\leftarrow$ sonPocas or tam(amigas(k)) $<$ 2;\\
		  sonSuficientes $=$ sonSuficientes $\&\&$ tam(amigas(k)) $==$ n-1);
	   }
    \If{(sonSuficientes)}{retornar true}
    \If{(sonPocas)}{retornar false}

	\textbf{var} solitaria : chica $\leftarrow$ primerElemento(gente);

	insertar(nombre(solitaria),enRonda);

	retornar  probarDistintasRondas(solitaria,solitaria);
	\BlankLine




	  \end{algorithm}
	  


%segundo algoritmo:

\vspace{3cm}
\incmargin{1em}
\linesnumbered
\restylealgo{boxed}

\textbf{probarDistintasRondas(prim : chica, ult : chica)}\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{T(n)}
		\BlankLine
	\eIf{(cuenta(amigas(ult),nombre(prim)) $\neq$ 0 $\&\&$ tam(gente) $=$ tam(enRonda) )}{retornar true;}{
		\textbf{var} res : bool\\
		\textbf{var} eraAmiga : bool $\leftarrow$ false \\
\BlankLine		
\ForEach{chi en gente}{
		\textbf{var} estaEnRonda : int $\leftarrow$ cuenta(enRonda,nombre(chi)) \\
		\textbf{var} esAmigaDeLaUltima : int $\leftarrow$ cuenta(amigas(ult),nombre(chi)) \\
		\textbf{var} restantesAmigasPrimera : int $\leftarrow$ tam(amigasPrimera) \\
		\textbf{var} esAmigaDeLaPrimera : int $\leftarrow$ cuenta(amigas(prim),nombre(chi)) \\
		  \BlankLine
	\If {( (estaEnRonda $=$ 0) $\&\&$ (esAmigaDeLaUltima $\neq$ 0) $\&\&$ (restantesAmigasPrimera $\neq$ 0) )}{
\BlankLine	
			\eIf{(esAmigaDeLaPrimera $\neq$ 0)}{
					eraAmiga $\leftarrow$ true;\\
					eliminar(amigasPrimera,nobre(chi));
				}{
					eraAmiga = false;
				}
				insertar(enRonda,nombre(chi));\\
				res $\leftarrow$ probarDistintasRondas(prim,chi);
\BlankLine	
			\eIf{(res)}
				{
					retornar true;
				}
				{
					borrar(enRonda,nombre(chi));\\
\BlankLine	
				\If{(eraAmiga)}{insertar(amigasPrimera,nombre(chi))}
						}
				}	
		}
		retornar false;
	}	


  \end{algorithm}


%\subsection{Análisis de la complejidad del algoritmo}
%\subsection[Detalles de Implementación}
%\subsection{Resultados}
%\subsection{Debate}
%\subsection{Comentarios}
%\subsection{Conclusiones}
