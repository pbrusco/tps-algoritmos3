\section{Ejercicio 1}


\subsection{Introducción}

\paragraph{}
El primer problema de este trabajo práctico consistió en dar un algoritmo que sea capaz de decir, dada una secuencia de números, la cantidad de números mínima a eliminar de la misma para que cumpla con cierta propiedad. En este caso, la propiedad que debía cumplir la secuencia  modificada era que la misma sea unimodal. Una secuencia es unimodal si la misma cumple que es creciente desde el primer elemento hasta cierta posición y desde dicha posición es decreciente hasta el final\footnote{Debe ser estrictamente creciente/decreciente}.

\paragraph{}
Además, se requirió que la complejidad del algoritmo que resolviera el problema antes mencionado, debía ser estrictamente menor que \Ode{n^3} (donde n es el tamaño de la secuencia).

\paragraph{}
Se pensaron varias formas de encarar y resolver este problema, finalmente se aplicó la técnica de \textit{programación dinámica}. En las secciones siguientes, daremos una explicación detallada de cómo se implementó el algoritmo, cuál es su complejidad temporal y cómo se comportó frente a distintos valores y tamaños de entrada.


\subsection{Explicación}

\paragraph{}
Desde el comienzo resultó bastante difícil encontrar dónde se podía aplicar el \textit{principio de optimalidad} para resolver este problema utilizando \textit{programación dinámica}. Luego, se pudo intuir que este problema, podía ser visto como una combinación de otro problema similar: encontrar la subsecuencia creciente/decreciente más larga. Básicamente, el razonamiento fue el siguiente:\\

Si para cada posición \textit{i} de la secuencia sabemos:
\begin{itemize}
	\item Longitud de la subsecuencia creciente más larga desde el principio hasta \textit{i} (que contenga al elemento i-ésimo)
	\item Longitud de la subsecuencia decreciente más larga desde \textit{i} hasta el final (que contenga al elemento i-ésimo)
\end{itemize}

entonces podemos decir cuál es el largo de una secuencia unimodal que tiene como ``pivote'' u objeto más grande al i-ésimo de la secuencia. Finalmente, sólo bastaría saber cuál es el ``pivote'' que maximice esa longitud, ya que conocer la longitud de la subsecuencia unimodal más larga es equivalente a encontrar la cantidad mínima de elementos a eliminar para transformar la secuencia dada en una secuencia unimodal, que es el problema que necesitabamos resolver.

\paragraph{}
Entonces, veamos como conseguimos la subsecuencia creciente más larga desde el principio hasta el pivote:


Para construir un algoritmo de programación dinámica definimos:
\begin{itemize}
	
\item $ascenso_i$ = longitud de la secuencia creciente más larga que termina con el número $v_i$
	
\item Relación de recurrencia:	 
  
  * $ascenso_0 = 0$

  * $ascenso_i  = max_{j<i} \left\lbrace ascenso_j + 1\right\rbrace  \;      $ (con $ v_j < v_i  $)

	
\item la solucion final: $max_{1\leq i\leq n} \{ascenso_i\}$
\end{itemize}
 \vspace*{0.5cm}
Veamos el pseudocódigo de completar\_ascensos para entender el mecanismo:
\vspace*{1cm}

void  \textbf{completar\_ascensos}(ascenso: vector<nat>, v: vector<int>)\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{O($tam(v)^2$)}
\BlankLine		
     \For{$i = 0;i<= tam(v);i++$}{
    ascenso[i] $\leftarrow$ maximoAsc(ascenso,v,i) + 1;}
  \end{algorithm}

	

\paragraph{}
Donde ascenso es un vector donde se va guardando , en la posicion i, la longitud del mayor ascenso hasta i. La función maximoAsc(ascenso,v,i) indica, dentro del vector ascenso, la maxima longitud de un ascenso hasta la posicion i-1 del vector tal que cumpla la siguiente propiedad:

\vspace*{1cm}

Si j es el indice del ascenso donde se encuentra el resultado, tiene que ocurrir que: \footnote{ver pseudocódigo en el anexo}

$$(\forall k \in [0...i) , v[k]<v[i]) \  ascenso[j] > ascenso[k]$$


Por lo tanto, de esta manera podemos obtener para cada pivote, la longitud del mayor ascenso hasta esa posición.

\vspace*{1cm}
Veamos un \textit{ejemplo}:

$v = \left\lbrace 9,5,2,8,7,3,1,6,4\right\rbrace$ 

Las subsecuencias ascendentes más largas son $\left\lbrace 2,3,4\right\rbrace$ o $\left\lbrace 2,3,6\right\rbrace$

\begin{center}
   \begin{tabular}{| l | c | c |c |c |c |c |c |c |c | }
     \hline
     sucesión & 9 & 5 & 2 & 8 & 7 & 3 & 1 & 6 & 4 \\ \hline
     longitud & 1& 1& 1& 2& 2& 2& 1 &3 & 3 \\ \hline
     
     \hline
   \end{tabular}
 \end{center}

Aquí podemos observar que en cada posición de la fila longitud, se encuentra la longitud de la secuencia creciente más larga hasta ese punto.

\paragraph{}
Una vez realizado este proceso, podemos obtener, ejecutando un algoritmo equivalente (pero desde el final hacia el principio) que obtenga, para cada posición, la longitud de la secuencia decreciente más larga desde la posición hacia el final. Al ejecutar esté proceso sobre el ejemplo obtendríamos:

\begin{center}
   \begin{tabular}{| l | c | c |c |c |c |c |c |c |c | }
     \hline
     sucesión & 9 & 5 & 2 & 8 & 7 & 3 & 1 & 6 & 4 \\ \hline
     ascendente & 1& 1& 1& 2& 2& 2& 1 &3 & 3 \\ \hline
     descendente & 5& 3& 2& 4& 3& 2& 1 &2 & 1 \\ \hline
          \hline
   \end{tabular}
 \end{center}

Luego, para decidir cual es el mejor pivot, nos basamos en dos filas extra implicitas que podemos ver a continuación :

\begin{center}
   \begin{tabular}{| l | c | c |c |c |c |c |c |c |c | }
     \hline
     sucesión 		& 9& 5& 2& 8& 7& 3& 1 &6 & 4 \\ \hline
     ascendente 	& 1& 1& 1& 2& 2& 2& 1 &3 & 3 \\ \hline
     descendente 	& 5& 3& 2& 4& 3& 2& 1 &2 & 1 \\ \hline
     suma	 	& 5& 3& 2& 5& 4& 3& 1 &4 & 3 \\ \hline
     tam(S) - suma;	& 4& 6& 7& 4& 5& 6& 8 &5 & 6 \\ \hline
     
          \hline
   \end{tabular}
 \end{center}


\paragraph{}
Donde $suma_i = ascendente_i + descendente_i - 1 \; \forall i \in [ 1..tam(s)]$ \\(esto quiere decir, la suma de las longitudes de la secuencia de mayor longitud creciente hasta i + la longitud de la secuencia de mayor longitud decreciente desde i). Se le resta 1 porque ambas secuencias incluyen al elemento de la posición i.

La fila tam(S)-suma representa, cuantos elementos NO fueron usados para esta ``escalera''. 


\paragraph{}
Por lo tanto se busca el máximo valor de la fila suma, lo que es equivalente a buscar el mínimo en la fila tam(s)-suma que representa la cantidad minima de borrados a realizar para lograr formar la secuencia unimodal y ese es el resultado devuelto por nuestra función.



\subsection{Análisis de la complejidad del algoritmo}

\paragraph{}
A continuación se calculará la complejidad del algortimo implementado en la función \textit{escalerar}, que es el que resuelve el problema que se planteo. Primero veamos el pseudocódigo de la función completa:
\vspace*{30pt}
void \textbf{escalerar}(v: vector$\langle$int$\rangle$)\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{O($tam(v)^2$)} 
\BlankLine		
      \textbf{var} max: nat;\\
      \textbf{var} ascenso: vector$\langle$nat$\rangle$(tam(v));\\
      \textbf{var} descenso: vector$\langle$nat$\rangle$(tam(v));\\
\BlankLine		
      completar\_ascensos(ascenso,v);\\
      completar\_descensos(descenso,v);\\	
\BlankLine		
      \For{$i = 0;i \leq tam(v);i++$}{
	\lIf(ascenso[i] $+$ descenso[i] $\geq$ max) max $\leftarrow$ ascenso[i] $+$ descenso[i];\\
	} 
\BlankLine		
	retornar  tam(v) $-$ max $+$ 1;\\



\end{algorithm}




\subsection{Anexo: Pseudocódigos}
\label{pseudocodigos1}


\vspace*{1cm}
Pseudocódigo de la función descenso y maximoAsc:
\\
\\

void \textbf{completar\_descensos}(descenso: vector$\langle$nat$\rangle$, v: vector$\langle$int$\rangle$)\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{O($tam(v)^2$)}
\BlankLine		
     \For{$i = tam(v);i \geq 0;i--$}{
    descenso[i] $\leftarrow$ maximoDes(descenso,v,i) + 1;}
  \end{algorithm}

\vspace*{1cm}

nat  \textbf{maximoAsc}(ascenso: vector$\langle$nat$\rangle$, v: vector$\langle$int$\rangle$,i: nat)\\
\SetKw{Orden}{Complejidad:}
	\begin{algorithm}[H]
	\Orden{O($i$)}
	\BlankLine		
      \textbf{var} res: nat
      res $\leftarrow$ 0
	\BlankLine		
     \For{$k = 0;k < i;k++$}{
  \lIf{v[j] $<$ v[i] and res $<$ ascenso[j]}{res $\leftarrow$ ascenso[j]}}
  \end{algorithm}



